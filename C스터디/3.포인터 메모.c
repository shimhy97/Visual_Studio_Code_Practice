주소를 직접 가르키는 거랑
주소에 가서 그 자료를 빼오는 것은 엄연히 다르다.

또한, 연산자의 종류가 다르면 오류가 난다.
포인터엔 주소연산자만
*포인터엔 자료가 저장된다.
(*numPtr = num1) 해당 주소에 값 저장 
(numPtr = &num1) 주소 참조

///
주소를 직접 프린트 할땐 %p를 쓴다.
printf("%p", numPtr1)
///

#include <stdio.h>

int main()
{
    int *numPtr;      // 포인터 변수 선언
    int num1 = 10;    // 정수형 변수를 선언하고 10 저장

    numPtr = &num1;   // num1의 메모리 주소를 포인터 변수에 저장

    *numPtr = 20;     // 역참조 연산자로 메모리 주소에 접근하여 20을 저장

    printf("%d\n", *numPtr);    // 20: 역참조 연산자로 메모리 주소에 접근하여 값을 가져옴
    printf("%d\n", num1);       // 20: 실제 num1의 값도 바뀜

    return 0;
}

포인터를 선언할 때도 *를 사용하고 역참조를 할 때도 *를 사용합니다. 
같은 * 기호를 사용해서 헷갈리기 쉽지만 선언과 사용을 구분해서 생각하면 됩니다.
즉, 포인터를 선언할 때 *는 "이 변수가 포인터다"라고 알려주는 역할이고,
포인터에 사용할 때 *는 "포인터의 메모리 주소를 역참조하겠다"라는 뜻입니다.

int *numPtr;                // 포인터. 포인터를 선언할 때 *
printf("%d\n", *numPtr);    // 역참조. 포인터에 사용할 때 *

강의 0209
루프 변수는 값을 직접 쓰는 것이 아니고 변수를 따로 지정해서 써주는게 좋다.
0 = false
그 외 = True >> 불 연산자

각 타입별로 일일이 포인터가 다르다
int* double* 다 다름..
다만, void 포인터의 경우 이를 무시하고 할당할 수 있다.

헐...값을 넘겨주는게 아니라 주소를 넘겨주는 방식을 쓸 수도 있네...!


#include <stdio.h>
#include <stdlib.h>    // malloc, free 함수가 선언된 헤더 파일
#include <string.h>    // memset 함수가 선언된 헤더 파일
